from codonpaths.constants import *
from codonpaths.utils import *
from collections import namedtuple


PathCount = namedtuple('PathCount', ['path', 's', 'ns'])


# Dictionary of codon pairs (codon1, codon2) and whether change is s/ns
# True if codon pair results in a synonymous change
# False if codon pair results in a nonsynonymous change
CODON_CHANGE_IS_SYNONYMOUS = {
    (k1, k2): v1 == v2
    for k1, v1 in GENETIC_CODE.items()
    for k2, v2 in GENETIC_CODE.items()
    if k1 != k2
}


def _count_changes(anc_codon, der_codon, paths, prev_changes=[]):
    """Returns list of one-hit transition paths between any two codons
    recursively.
    
    Parameters
    ----------
    anc_codon : str
        Ancestral codon
    der_codon : str
        Derived codon
    paths : list
        List used to store paths
    prev_changes : list, optional
        List of previous changes encountered while traversing a transition path.
    
    """
    # Base case
    # Adds the list of previous changes seen in this transition path
    # to the paths list.
    if anc_codon == der_codon:
        if prev_changes:
            paths += [prev_changes]
        return
    # Checks whether ancestral and derived characters are the same or not.
    # Recursively calls this function if characters are different.
    # A new ancestral codon is generated by replacing 
    # the current ancestral character with its derived counterpart.
    for i in range(3):
        anc_char, der_char = anc_codon[i], der_codon[i]
        if anc_char != der_char:
            step_codon = anc_codon[:i] + der_char + anc_codon[i+1:]
            curr_change = (anc_codon, step_codon)
            _count_changes(step_codon, der_codon, paths, prev_changes + [curr_change])


def count_changes(anc_codon, der_codon):
    """Returns all the transition paths between any two codons.

    Paramters
    ---------
    anc_codon : str
    der_codon : str

    Returns
    -------
    list
        Each transition path is a list of tuples indicating one-hit changes
        that are necessary to go from the ancestral codon to the derived codon.

    """
    paths = []
    _count_changes(anc_codon, der_codon, paths, prev_changes=[])
    return paths


def count_sns_changes(path, is_syn_dict):
    """Returns the total number of synonymous and nonsynonymous changes occuring in the given transition path.
    
    Parameters
    ----------
    path : list of tuple
        List of tuples inidcating the set of one-hit changes that form the transition path from the ancestral codon to the derived codon.
    is_syn_dict : dict
        Dictionary with 2-codon tuple keys whose values indicate whether the
        codon pair represents a synonymous change. 
        True means the pair produces a synonymous mutation, 
        False if the pair represents a nonsynonymous mutation.
    
    Returns
    -------
    PathCount
        Namedtuple that contains the path and the total number of synonymous and
        nonsynonymous mutations for the path.

    """
    syn = 0
    nonsyn = 0
    for pair in path:
        if pair[0] == pair[1]:
            continue
        
        if is_syn_dict[pair]:
            syn += 1
        else:
            nonsyn += 1
    return PathCount(tuple(path), syn, nonsyn)

# Dictionary of codon pairs (codon1, codon2) and all possible paths for the pair
CODON_CHANGE_PATHS = {
    (k1, k2): [count_sns_changes(path, CODON_CHANGE_IS_SYNONYMOUS)
               for path in count_changes(k1, k2)]
    for k1 in GENETIC_CODE.keys()
    for k2 in GENETIC_CODE.keys()
}


def generate_codon_path_probs(codon_paths_dict, s_prob, ns_prob, no_stop_codon_path=True):
    """Generates a dictionary of path probabilities based on the given
    synonymous and nonsynonymous rates.
    
    Parameters
    ----------
    codon_paths_dict : dict
        Dictionary of codon pairs and all possible paths for the pair
    s_rate : float
        Synonymous probability
    ns_rate : float
        Nonsynonymous probability
    no_stop_codon_path : bool, optional
        Whether or not to include paths containing stop codons
        (default is True, which removes paths when it contains the stop codon)

    Returns
    -------
    dict
        Dictionary of codon pairs, with each value being a dictionary
        of path and path probabilities.

    """
    total_prob = s_prob + ns_prob
    s_prob, ns_prob = s_prob/total_prob, ns_prob/total_prob
    path_probs = {}
    for pair, paths in codon_paths_dict.items():
        if not paths:
            path_probs[pair] = {pair: 1.0}
            continue

        if no_stop_codon_path:
            weighted_paths = {}
            for p in paths:
                has_stop_codon = [
                    1 for pair in p.path
                    if ('TAG' in pair) or 
                       ('TGA' in pair) or
                       ('TAA' in pair)
                ]
                if sum(has_stop_codon) == 0:
                    weighted_paths[tuple(p.path)] = \
                        (ns_prob ** p.ns) * (s_prob ** p.s)
        else:
            weighted_paths = {
                tuple(p.path): (ns_prob ** p.ns) * (s_prob ** p.s)
                for p in paths
            }
        total_prob = sum(weighted_paths.values())
        path_probs[pair] = {
            tuple(collapse_path(path)): weight/total_prob
            for path, weight in weighted_paths.items()
        }
    return path_probs
